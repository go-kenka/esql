// Code generated by esql, DO NOT EDIT.
package sql

import (
	"context"
	"fmt"
	stdSql "database/sql"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/jmoiron/sqlx"
    "github.com/go-kenka/esql"
	"github.com/qustavo/sqlhooks/v2"
	"time"

	"{{$.Pkg}}/migrate"
	{{- range $i,$t := .Tables }}
	"{{$.Pkg}}/{{$t.Name}}"
	{{- end }}
)

// Client .
type Client struct {
	DB      *sqlx.DB
	Builder *sql.DialectBuilder
	Schema *migrate.Schema
    {{- range $i,$t := .Tables }}
	{{$t.Name | camelCase}} *{{$t.Name}}.{{$t.Name | camelCase}}Client
	{{- end }}
}

// NewClient .
func NewClient(db *sqlx.DB) *Client {
	drv := migrate.Driver(db.DriverName(), db.DB)
	return &Client{
		DB:      db,
		Builder: sql.Dialect(db.DriverName()),
		Schema: migrate.NewSchema(drv),
		{{- range $i,$t := .Tables }}
		{{$t.Name | camelCase}}: {{$t.Name}}.New{{$t.Name | camelCase}}Client(db),
		{{- end }}
	}
}

// Open .
func Open(driverName, dataSourceName string) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		db, err := stdSql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		driver := fmt.Sprintf("%sWithHooks", driverName)
		stdSql.Register(driver, sqlhooks.Wrap(db.Driver(), &Hooks{}))

		ndb, err := sqlx.Open(driver, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(ndb), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}


// Tx .
type Tx struct {
	esql.Driver
	tx        *sqlx.Tx
	Builder   *sql.DialectBuilder
	{{- range $i,$t := .Tables }}
	{{$t.Name | camelCase}} *{{$t.Name}}.{{$t.Name | camelCase}}Client
	{{- end }}
}

func (c *Client) BeginTx(ctx context.Context, opts *stdSql.TxOptions) (*Tx, error) {
	tx, err := c.DB.BeginTxx(ctx, opts)
	if err != nil {
		return nil, err
	}

	return &Tx{
		Driver:      tx,
		Builder: sql.Dialect(tx.DriverName()),
		{{- range $i,$t := .Tables }}
		{{$t.Name | camelCase}}: {{$t.Name}}.New{{$t.Name | camelCase}}Client(tx),
		{{- end }}
	}, nil
}

func (t *Tx) Commit() error {
	return t.tx.Commit()
}

func (t *Tx) Rollback() error {
	return t.tx.Rollback()
}


// Hooks satisfies the sqlhook.Hooks interface
type Hooks struct{}

// Before hook will print the query with it's args and return the context with the timestamp
func (h *Hooks) Before(ctx context.Context, query string, args ...interface{}) (context.Context, error) {
	fmt.Printf("> %s %q", query, args)
	return context.WithValue(ctx, "begin", time.Now()), nil
}

// After hook will get the timestamp registered on the Before hook and print the elapsed time
func (h *Hooks) After(ctx context.Context, query string, args ...interface{}) (context.Context, error) {
	begin := ctx.Value("begin").(time.Time)
	fmt.Printf(". took: %s\n", time.Since(begin))
	return ctx, nil
}
